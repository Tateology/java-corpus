/**
 * NOAA's National Climatic Data Center
 * NOAA/NESDIS/NCDC
 * 151 Patton Ave, Asheville, NC  28801
 * 
 * THIS SOFTWARE AND ITS DOCUMENTATION ARE CONSIDERED TO BE IN THE 
 * PUBLIC DOMAIN AND THUS ARE AVAILABLE FOR UNRESTRICTED PUBLIC USE.  
 * THEY ARE FURNISHED "AS IS." THE AUTHORS, THE UNITED STATES GOVERNMENT, ITS
 * INSTRUMENTALITIES, OFFICERS, EMPLOYEES, AND AGENTS MAKE NO WARRANTY,
 * EXPRESS OR IMPLIED, AS TO THE USEFULNESS OF THE SOFTWARE AND
 * DOCUMENTATION FOR ANY PURPOSE. THEY ASSUME NO RESPONSIBILITY (1)
 * FOR THE USE OF THE SOFTWARE AND DOCUMENTATION; OR (2) TO PROVIDE
 * TECHNICAL SUPPORT TO USERS.
 */

package gov.noaa.ncdc.wct.decoders.nexrad;

import gov.noaa.ncdc.wct.decoders.DecodeException;
import gov.noaa.ncdc.wct.decoders.DecodeHintNotSupportedException;
import gov.noaa.ncdc.wct.decoders.MaxGeographicExtent;
import gov.noaa.ncdc.wct.decoders.StreamingProcess;
import gov.noaa.ncdc.wct.decoders.StreamingProcessException;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;

import org.geotools.ct.MathTransform;
import org.geotools.feature.AttributeType;
import org.geotools.feature.AttributeTypeFactory;
import org.geotools.feature.Feature;
import org.geotools.feature.FeatureCollection;
import org.geotools.feature.FeatureCollections;
import org.geotools.feature.FeatureIterator;
import org.geotools.feature.FeatureType;
import org.geotools.feature.FeatureTypeFactory;
import org.geotools.pt.CoordinatePoint;

import com.vividsolutions.jts.geom.Coordinate;
import com.vividsolutions.jts.geom.GeometryFactory;
import com.vividsolutions.jts.geom.Point;

/**
 * Decodes NHI NEXRAD Level-III Hail Index alphanumeric product.
 *  
 * From 2620003J.pdf 19.1:
 *  
 * "This product shall provide, for each storm cell identified by the 
 * Storm Cell Identification and Tracking algorithm, the Probability 
 * of Hail, the Probability of Severe Hail, and the Maximum Expected 
 * Hail Size. The hail probabilities and size shown for each storm cell 
 * shall be generated by the Hail Algorithm. This product shall be 
 * produced in a tabular format of alphanumeric values, as a stand alone 
 * graphic product, and in a format for generating graphic overlays to 
 * other products. This product shall include a standard set of annotations. 
 * Upon user request, all site adaptable parameters identified as inputs 
 * to the algorithm(s) used to generate data for this product shall be 
 * available at the alphanumeric display."
 * 
 * @author steve.ansari
 * @created June 4, 2004
 */
public class DecodeHail implements DecodeL3Alpha {

    private static final Logger logger = Logger.getLogger(DecodeHail.class.getName());

    private String[] metaLabelString = new String[3];
    private FeatureCollection fc = FeatureCollections.newCollection();
    private FeatureType schema = null;
    private GeometryFactory geoFactory = new GeometryFactory();
    private java.awt.geom.Rectangle2D.Double wsrBounds;
    private DecodeL3Header header;
    private String[] supplementalData = new String[2];
    private WCTProjections nexradProjection = new WCTProjections();
    private MathTransform nexradTransform;
    private String datetime;

    private HashMap<String, Object> decodeHints = new HashMap<String, Object>();


    /**
     * Constructor
     * 
     * @param header
     *            Description of the Parameter
     * @throws IOException 
     */
    public DecodeHail(DecodeL3Header header) throws DecodeException, IOException {
        this.header = header;
        this.wsrBounds = getExtent();
        decodeData();
    }

    /**
     * Returns the feature types used for these features
     * 
     * @return The featureType value
     */
    public FeatureType[] getFeatureTypes() {
        return new FeatureType[] {schema};
    }

    /**
     * Returns the LineFeatureType -- Always null in this case
     * 
     * @return Always null for this alphanumeric product
     */
    public FeatureType getLineFeatureType() {
        return null;
    }

    /**
     * Returns Rectangle.Double Bounds for the NEXRAD Site calculated during
     * decode. (unique to product) Could be 248, 124 or 32 nmi.
     * 
     * @return The nexradExtent value
     */
    public java.awt.geom.Rectangle2D.Double getNexradExtent() {
        return wsrBounds;
    }

    /**
     * Returns default display symbol type
     * 
     * @return The symbol type
     */
    public String getDefaultSymbol() {
        return org.geotools.styling.StyleBuilder.MARK_TRIANGLE;
    }

    /**
     * Returns the specified supplemental text data (index=1 == Block2, index2 ==
     * Block3, etc...)
     */
    public String getSupplementalData(int index) {
        if (supplementalData[index] != null) {
            return supplementalData[index];
        }
        else {
            return new String("NO DATA");
        }
    }

    /** 
     * Returns the supplemental text data array  
     */
    public String[] getSupplementalDataArray() {
        return supplementalData;
    }

    public String getMetaLabel(int index) {
        if (metaLabelString[index] == null) {
            return "";
        }
        else {
            return metaLabelString[index];
        }
    }

    private void makeMetaLabelStrings() {

        FeatureIterator fi = fc.features();
        if (fi.hasNext()) { // only use first and thus strongest reading
            Feature f = fi.next();
            
            String id = f.getAttribute("id").toString().trim();
            String prob = f.getAttribute("prob").toString().trim();
            String size = f.getAttribute("maxsize").toString().trim();
            
            metaLabelString[0] = "MAX ID: " + id;
            metaLabelString[1] = "PROB: " + prob + (prob.equals("N/A") ? "" : "%");
            metaLabelString[2] = "MAX SIZE: " + size + (size.equals("N/A") ? "" : " in");
        }
        else {
            metaLabelString[0] = "NO HAIL PRESENT";
        }

    }







//    @Override
    public Map<String, Object> getDecodeHints() {
        return decodeHints;
    }

//    @Override
    public void setDecodeHint(String hintKey, Object hintValue)
    throws DecodeHintNotSupportedException {
        throw new DecodeHintNotSupportedException("DecodeHail", hintKey, decodeHints);

    }


    /**
     * Decodes data and stores with in-memory FeatureCollection
     * @return
     * @throws DecodeException
     */
//    @Override
    public void decodeData() throws DecodeException, IOException {
        fc.clear();

        StreamingProcess process = new StreamingProcess() {
            public void addFeature(Feature feature)
            throws StreamingProcessException {
                fc.add(feature);
            }
            public void close() throws StreamingProcessException {
                logger.info("STREAMING PROCESS close() ::: fc.size() = "+fc.size());
            }    		
        };

        decodeData(new StreamingProcess[] { process } ); 	
    }


//    @Override
    public void decodeData(StreamingProcess[] processArray)
    throws DecodeException, IOException {

        decodeData(processArray, true);

    }

//    @Override
    public void decodeData(StreamingProcess[] processArray, boolean autoClose)
    throws DecodeException, IOException {


        try {
            // Use Geotools Proj4 implementation to get MathTransform object
            nexradTransform = nexradProjection.getRadarTransform(header);
        } catch (Exception e) {
            throw new DecodeException("PROJECTION TRANSFORM ERROR", header.getDataURL());
        }

        datetime = header.getDate() + header.getHourString() + header.getMinuteString() + header.getSecondString();

        // Set up attribute table
        try {
            AttributeType geom = AttributeTypeFactory.newAttributeType("geom", Point.class);
            AttributeType wsrid = AttributeTypeFactory.newAttributeType("wsrid", String.class, true, 5);
            AttributeType datetime = AttributeTypeFactory.newAttributeType("datetime", String.class, true, 15);
            AttributeType lat = AttributeTypeFactory.newAttributeType("lat", Double.class, true, 10);
            AttributeType lon = AttributeTypeFactory.newAttributeType("lon", Double.class, true, 10);
            AttributeType id = AttributeTypeFactory.newAttributeType("id", String.class, true, 3);
            AttributeType range = AttributeTypeFactory.newAttributeType("range", Double.class, true, 7);
            AttributeType azim = AttributeTypeFactory.newAttributeType("azim", Double.class, true, 7);
            AttributeType sevprob = AttributeTypeFactory.newAttributeType("sevprob", String.class, true, 5);
            AttributeType prob = AttributeTypeFactory.newAttributeType("prob", String.class, true, 5);
            AttributeType maxsize = AttributeTypeFactory.newAttributeType("maxsize", String.class, true, 5);
            AttributeType[] attTypes = { geom, wsrid, datetime, lat, lon, id, range, azim, sevprob, prob, maxsize };
            schema = FeatureTypeFactory.newFeatureType(attTypes, "Hail Data");
        } catch (Exception e) {
            e.printStackTrace();
        }

        // Reset feature index counter
        int geoIndex = 0;

        // Initiate binary buffered read
        try {

            // Decode the text blocks (block 2 and 3)
            DecodeL3AlphaGeneric decoder = new DecodeL3AlphaGeneric();
            decoder.decode(header);

            logger.info("----------- VERSION: "+header.getVersion()+" ------------ \n");
            logger.info("----------- BLOCK 2 ----------- \n"+decoder.getBlock2Text());
            logger.info("----------- BLOCK 3 ----------- \n"+decoder.getBlock3Text());


            // Build text for block 2 data
            StringBuffer sb = new StringBuffer();
            sb.append("  HAIL INDEX SUPPLEMENTAL DATA 1\n\n");
            sb.append("  ABBREVIATIONS:\n");
            sb.append("  AZ    = Azimuth Angle From Radar \n");
            sb.append("          (In Degrees where 0 deg = North, 90 = East, 180 = South, etc...)\n");
            sb.append("  RAN   = Range (Distance) From Radar (In Nautical Miles (nmi))\n");
            sb.append("  POSH  = Probability of Severe Hail\n");
            sb.append("  POH   = Probability of Hail\n");
            sb.append("  MAX HAIL SIZE = Size in inches (in)\n\n");
            if (decoder.getBlock2Text() != null) {
            	sb.append(decoder.getBlock2Text());
            }
            else {
            	supplementalData[0] = " NO HAIL FEATURES PRESENT";
            }
            sb.append("\n\n");
            supplementalData[0] = sb.toString();
            

            // Build text for block 3 data
            sb = new StringBuffer();
            sb.append("  HAIL INDEX SUPPLEMENTAL DATA 2\n\n");                  
            if (decoder.getBlock3Text() != null) {
            	sb.append(decoder.getBlock3Text());
            }
            else {
            	supplementalData[0] = " PARAMETER DATA NOT PRESENT";
            }
            sb.append("\n\n");
            supplementalData[1] = sb.toString();


            String block2Text = decoder.getBlock2Text();
            String[] lines = (block2Text == null) ? new String[0] : block2Text.split("\n");




            logger.info("lines.length = "+lines.length);

            // Build text for block 3 data

            // Decode block 2 data into features

            if (lines.length == 0) {
                metaLabelString[0] = "NO HAIL PRESENT";
                return;
            }

            // Set up vectors to hold data until the data is fully read
            ArrayList<String> ids = new ArrayList<String>();
            ArrayList<Double> lats = new ArrayList<Double>();
            ArrayList<Double> lons = new ArrayList<Double>();
            ArrayList<Double> ranges = new ArrayList<Double>();
            ArrayList<Double> azims = new ArrayList<Double>();
            ArrayList<String> sevprobs = new ArrayList<String>();
            ArrayList<String> probs = new ArrayList<String>();
            ArrayList<String> maxsizes = new ArrayList<String>();
            ArrayList<Coordinate> coords = new ArrayList<Coordinate>();

            int hitCount = 0;
            int numEntries = 6;

            if (header.getVersion() > 1.0) {
                throw new DecodeException("UNKNOWN NEXRAD HAIL FILE VERSION: " + header.getVersion(), header
                        .getDataURL());
            }


            for (int i = 0; i < lines.length; i++) {

                String str = lines[i];

                // skip empty lines
                if (lines[i].trim().length() == 0) {
                    continue;
                }


                //              ----------- VERSION 0 -----------------
                //              0         1         2         3         4         5         6         7
                //              01234567890123456789012345678901234567890123456789012345678901234567890
                //                STORM ID         Q         T                                                  
                //                AZ   RAN   96  126  123  111                                                  
                //                HAIL IND  PROBABLE  POSITIVE

                //                STORM ID        59        28        57        52        58                    
                //                AZ   RAN   58  162   75   58   46   70   59  121   33  111                    
                //                HAIL IND  NONE      POSITIVE  POSITIVE  NONE      NONE    

                if (header.getVersion() == 0) {

                    logger.info("hitCount="+hitCount+" ::: "+str);

                    // Extract geodata
                    if (hitCount == 0) {
                        try {
                            for (int n = 0; n < numEntries; n++) {
                                String idText = str.substring(18 + n * 10, 20 + n * 10);
                                if (idText.trim().length() > 0) {
                                    ids.add(idText);
                                    logger.info("ADDING ID: "+str.substring(18 + n * 10, 20 + n * 10));
                                }
                                else {
                                    numEntries = n;
                                    logger.info("SETTING numEntries="+numEntries);
                                }
                            }
                        } catch (Exception e) {
                            logger.info("CAUGHT DECODEHAIL EXCEPTION 1");
                        }
                    }
                    else if (hitCount == 1) {
                        try {
                            for (int n = 0; n < numEntries; n++) {
                                azims.add(new Double(str.substring(12 + n * 10, 15 + n * 10)));
                                ranges.add(new Double(str.substring(17 + n * 10, 20 + n * 10)));

                                double localrange = ((Double) ranges.get(ranges.size() - 1)).doubleValue();
                                double localazim = ((Double) azims.get(azims.size() - 1)).doubleValue();
                                // Correct for an azim of 0
                                if (localazim == 0.0 || localazim == 180.0 || localazim == 360.0) {
                                    localazim += 0.000001;
                                }
                                double[] geoXY = (nexradTransform.transform(new CoordinatePoint(localrange
                                        * Math.sin(Math.toRadians(localazim)) * 1852.0, localrange
                                        * Math.cos(Math.toRadians(localazim)) * 1852.0), null)).getCoordinates();

                                coords.add(new Coordinate(geoXY[0], geoXY[1]));
                                lats.add(new Double(geoXY[1]));
                                lons.add(new Double(geoXY[0]));

                                logger.info("ADDING COORDINATE: ("+(n+1)+"/"+numEntries+") "+new Coordinate(geoXY[0], geoXY[1]).toString());
                            }
                        } catch (Exception e) {
                            e.printStackTrace();
                            logger.warning("CAUGHT DECODEHAIL EXCEPTION 2");
                        }
                    }
                    else if (hitCount == 2) {
                        try {
                            for (int n = 0; n < numEntries; n++) {
                                sevprobs.add("N/A");
                                probs.add(str.substring(10 + n * 10, 20 + n * 10));
                                maxsizes.add("N/A");

                                logger.info("ADDING PROB: "+str.substring(10 + n * 10, 20 + n * 10));
                            }
                        } catch (Exception e) {
                            logger.info("CAUGHT DECODEHAIL EXCEPTION 3");
                        }
                    }
                    if (str.trim().length() > 0) {
                        hitCount++;
                    }

                    // reset hitCount
                    if (hitCount == 3) {
                        hitCount = 0;
                    }
                }

                //              ----------- VERSION 1 -----------------
                //              0         1         2         3         4         5         6         7
                //              01234567890123456789012345678901234567890123456789012345678901234567890
                //                STORM ID            D2       L4       Q1       V1       D1       W3
                //                AZ/RAN         339/ 70  286/ 82  290/ 89  309/ 80  312/ 77    9/ 71
                //                POSH/POH         0/  0    0/  0    0/  0    0/  0    0/  0    0/  0
                //                MAX HAIL SIZE     0.00     0.00     0.00     0.00     0.00     0.00
                //                0/-20 C TEMP ALT 10.5/20.0 KFT(MSL) - LAST CHANGED 13:22 11/10/02   

                else if (header.getVersion() == 1) {

                    logger.info("hitCount="+hitCount+" ::: "+str);


                    // Extract geodata
                    if (hitCount == 0) {
                        try {
                            for (int n = 0; n < numEntries; n++) {
                                String idText = str.substring(22 + n * 9, 24 + n * 9);
                                if (idText.trim().length() > 0) {
                                    ids.add(idText);
                                    logger.info("ADDING ID: "+str.substring(22 + n * 9, 24 + n * 9));
                                }
                                else {
                                    numEntries = n;
                                    logger.info("SETTING numEntries="+numEntries);
                                }
                            }
                        } catch (Exception e) {
                            logger.warning("CAUGHT DECODEHAIL EXCEPTION 1");
                        }
                    }
                    else if (hitCount == 1) {
                        try {
                            for (int n = 0; n < numEntries; n++) {
                                azims.add(new Double(str.substring(17 + n * 9, 20 + n * 9)));
                                ranges.add(new Double(str.substring(21 + n * 9, 24 + n * 9)));

                                double localrange = ((Double) ranges.get(ranges.size() - 1)).doubleValue();
                                double localazim = ((Double) azims.get(azims.size() - 1)).doubleValue();
                                // Correct for an azim of 0
                                if (localazim == 0.0 || localazim == 180.0 || localazim == 360.0) {
                                    localazim += 0.000001;
                                }
                                double[] geoXY = (nexradTransform.transform(new CoordinatePoint(localrange
                                        * Math.sin(Math.toRadians(localazim)) * 1852.0, localrange
                                        * Math.cos(Math.toRadians(localazim)) * 1852.0), null)).getCoordinates();

                                coords.add(new Coordinate(geoXY[0], geoXY[1]));
                                lats.add(new Double(geoXY[1]));
                                lons.add(new Double(geoXY[0]));

                                logger.info("ADDING COORDINATE: "+new Coordinate(geoXY[0], geoXY[1]).toString());
                            }
                        } catch (Exception e) {
                            e.printStackTrace();
                            logger.info("CAUGHT DECODEHAIL EXCEPTION 2");
                        }
                    }
                    else if (hitCount == 2) {
                        try {
                            for (int n = 0; n < numEntries; n++) {
                            	String sevprob = str.substring(17 + n * 9, 20 + n * 9);
                            	String prob = str.substring(21 + n * 9, 24 + n * 9);
                            	if (sevprob.trim().toUpperCase().equals("UNK")) sevprob = "N/A";
                            	if (prob.trim().toUpperCase().equals("OWN")) prob = "N/A";
                                sevprobs.add(sevprob);
                                probs.add(prob);

                                logger.info("ADDING SEVPROB: "+str.substring(17 + n * 9, 20 + n * 9));
                                logger.info("ADDING PROB: "+str.substring(21 + n * 9, 24 + n * 9));
                            }
                        } catch (Exception e) {
                            logger.warning("CAUGHT DECODEHAIL EXCEPTION 3");
                        }
                    }
                    else if (hitCount == 3) {
                        try {
                            for (int n = 0; n < numEntries; n++) {
                            	String maxsize = str.substring(19 + n * 9, 24 + n * 9);
                            	if (maxsize.trim().toUpperCase().equals("KNOWN")) maxsize = "N/A";
                                maxsizes.add(maxsize);
                                logger.info("ADDING MAXSIZES: "+str.substring(19 + n * 9, 24 + n * 9));
                            }
                        } catch (Exception e) {
                            logger.info("CAUGHT DECODEHAIL EXCEPTION 4");
                        }
                    }
                    if (str.trim().length() > 0) {
                        hitCount++;
                    }

                    // reset hitCount and skip a line
                    if (hitCount == 4) {
                        hitCount = 0;
                        i++;
                    }
                }
                else {
                    throw new DecodeException("UNKNOWN NEXRAD HAIL FILE VERSION: " + header.getVersion(), header
                            .getDataURL());
                }

            }

            logger.info("ids.size() = "+ids.size());
            logger.info("lats.size() = "+lats.size());
            logger.info("lons.size() = "+lons.size());
            logger.info("coords.size() = "+coords.size());
            logger.info("ranges.size() = "+ranges.size());
            logger.info("azims.size() = "+azims.size());
            logger.info("sevprobs.size() = "+sevprobs.size());
            logger.info("probs.size() = "+probs.size());
            logger.info("maxsizes.size() = "+maxsizes.size());

            // Extract values and add to feature collection
            for (int n = 0; n < ids.size(); n++) {
                try {
                    // create the feature
                    Feature feature = schema.create(
                            new Object[]{
                                    geoFactory.createPoint((Coordinate) coords.get(n)),
                                    header.getICAO(),
                                    datetime,
                                    (Double) lats.get(n),
                                    (Double) lons.get(n),
                                    ((String) ids.get(n)).trim(),
                                    (Double) ranges.get(n),
                                    (Double) azims.get(n),
                                    ((String) sevprobs.get(n)).trim(),
                                    ((String) probs.get(n)).trim(),
                                    ((String) maxsizes.get(n)).trim()
                            },
                            new Integer(geoIndex++).toString());

                    // add to streaming processes
                    for (int s=0; s<processArray.length; s++) {
                        processArray[s].addFeature(feature);
                    }
                    //logger.info("ADDED FEATURE: "+feature);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }


            makeMetaLabelStrings();

        } catch (Exception e) {
            e.printStackTrace();
            throw new DecodeException("DECODE EXCEPTION IN HAIL FILE - CODE 1 ", header.getDataURL());
        }
    }

    /**
     * Gets the features attribute of the DecodeHail object
     * 
     * @return The features value
     */
    public FeatureCollection getFeatures() {
        return fc;
    }

    /**
     * Gets the line features attribute of the DecodeHail object
     * 
     * @return The features value
     */
    public FeatureCollection getLineFeatures() {
        return null;
    }







    private java.awt.geom.Rectangle2D.Double getExtent() {
        return (MaxGeographicExtent.getNexradExtent(header.getLat(), header.getLon()));
    }

}
